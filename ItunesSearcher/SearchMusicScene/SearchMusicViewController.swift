//
//  SearchMusicViewController.swift
//  ItunesSearcher
//
//  Created by Михаил Звягинцев on 25.10.2021.
//  Copyright (c) 2021 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol SearchMusicDisplayLogic: AnyObject {

    func displaySearchAlbumsResult(viewModel: SearchMusic.SearchAlbums.ViewModel)
    func displayAlert(with text: String)
    func searchFromHistory()
}

class SearchMusicViewController: UIViewController {

    private var searchBar = UISearchBar()
    private var collectionView: UICollectionView!
    private let layout = UICollectionViewFlowLayout()
    private let activityIndicator = UIActivityIndicatorView()

    var interactor: SearchMusicBusinessLogic?
    var router: SearchMusicDataPassing?

    private var albumsInfo: [SearchMusic.SearchAlbums.ViewModel.AlbumData] = []
    private let albumCellId = "CellId"

    override func viewDidLoad() {
        super.viewDidLoad()
        SearchMusicConfigurator.shared.configure(with: self)
        hideKeyboardOnTap()
        configureView()
        collectionView.dataSource = self
        collectionView.delegate = self
        searchBar.delegate = self
    }

    private func layoutViews() {
        [searchBar, collectionView].forEach{$0.translatesAutoresizingMaskIntoConstraints = false}
        let searchBarConstraints  = [
            searchBar.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor),
            searchBar.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor),
            searchBar.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor),
            searchBar.heightAnchor.constraint(equalToConstant: 50)
        ]
        let collectionViewConstraints = [
            collectionView.topAnchor.constraint(equalTo: searchBar.bottomAnchor),
            collectionView.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor),
            collectionView.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor),
            collectionView.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor)
        ]
        [searchBarConstraints, collectionViewConstraints].forEach{NSLayoutConstraint.activate($0)}
    }

    private func configureView() {
        searchBar.searchBarStyle = .default
        searchBar.placeholder = "Search album..."
        title = "Search"

        let layout: UICollectionViewFlowLayout = UICollectionViewFlowLayout()
        layout.sectionInset = UIEdgeInsets(top: 10, left: 10, bottom: 10, right: 10)
        let itemSideSize = view.frame.width/10
        layout.itemSize = CGSize(width: itemSideSize, height: itemSideSize + 80)

        collectionView = UICollectionView(frame: .zero, collectionViewLayout: layout)
        collectionView.register(AlbumInfoCollectionViewCell.self, forCellWithReuseIdentifier: albumCellId)

        activityIndicator.frame.size = CGSize(width: 25, height: 25)
        activityIndicator.center = view.center
        activityIndicator.hidesWhenStopped = true

        [searchBar, collectionView, activityIndicator].forEach{view.addSubview($0)}
        layoutViews()
    }

    func searchAlbums(with text: String) {
        let request = SearchMusic.SearchAlbums.Request(searchText: text)
        interactor?.searchAlbums(request: request)
    }
}

extension SearchMusicViewController: SearchMusicDisplayLogic {

    func displayAlert(with text: String) {
        DispatchQueue.main.async {
            self.showAlert(title: "Search error", message: text)
            self.activityIndicator.stopAnimating()
            self.albumsInfo = []
            self.collectionView.reloadData()
        }
    }

    func displaySearchAlbumsResult(viewModel: SearchMusic.SearchAlbums.ViewModel) {
        DispatchQueue.main.async {
            self.albumsInfo = viewModel.albumsData
            self.collectionView.reloadData()
            self.activityIndicator.stopAnimating()
            if !self.albumsInfo.isEmpty {
                self.collectionView?.scrollToItem(at: IndexPath(row: 0, section: 0), at: .top, animated: false)
            }
        }
    }
    
    func searchFromHistory() {
        searchBar.text = nil
    }
}

//MARK: Collection view
extension SearchMusicViewController: UICollectionViewDataSource, UICollectionViewDelegate {
    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        return albumsInfo.count
    }

    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: albumCellId, for: indexPath) as! AlbumInfoCollectionViewCell
        let albumInfo = albumsInfo[indexPath.row]
        cell.configure(albumURL: albumInfo.imageURL, albumTitle: albumInfo.title, artist: albumInfo.artist)
        return cell
    }

    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
        router?.showAlbumDetailsViewController(at: indexPath.row)
    }
}

//MARK: Search bar
extension SearchMusicViewController: UISearchBarDelegate {
    
    func searchBarSearchButtonClicked(_ searchBar: UISearchBar) {
        if let text = searchBar.text, text.count > 1 {
            activityIndicator.startAnimating()
            searchAlbums(with: text)
            view.endEditing(true)
        }
    }
}
